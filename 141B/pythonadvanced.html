<!DOCTYPE html>
<!-- This page was generated by GitHub Pages using the Cayman theme by Jason Long -->
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>141B: More Python</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">141B: Lesson 4</h1>
      <h2 class="project-tagline">More Python</h2>
    </section>

    <section class="main-content">
      <h3>Object Oriented Programming</h3>

      <p>
      Consider the <code>sum()</code> operation.  We can apply it to a list of numbers, and it will sum those numbers.
      Without the object type, the list of numbers, it is not clear what to sum.
      It doesn't make much sense to apply it to a string or a dictionary.
      So, sum is really made with a certain type in mind.

      A variable's type determines how the variable is stored and manipulated.
	Try the following commands in ipython:
	<ul>
	  <li><code>1 + 4</code></li>
	  <li><code>['a','b'] + ['c']</code></li>
	  <li><code>'ab' + 'c'</code></li>
	  <li><code>True + False</code></li>
	  <li><code>{'141A':1, '141B': 2} + {'141C': 3}</code></li>
	</ul>
	So + does different things based on the type.
	You can see what the type of these objects are with <code>type([variable])</code>.
	For integers + is addition, for lists and strings + concatenates, for boolean + converts them into integers first (1 or 0) and then adds, and for dictionaries + is undefined.
	In fact, you can make your own variable types (called classes) and redefine + for that class.
	Doing this is an example of object oriented programming, and redefining + is an example of overloading operators.

      <div class="youtube">
	<iframe width="560" height="315" src="https://www.youtube.com/embed/3Hr04vkVXHQ" frameborder="0" allowfullscreen></iframe>
	<b>Sum and +:</b> Here is an example of overloading and what sum does under the hood.
      </div>

	You will rarely be doing any object oriented programming of your own, such as defining custom classes, so I will not go into that at the moment.
      </p>

      <h4>Create a list, dictionary, integer, bool, and string in ipython (or Jupyter).  If the object is a then type <code>a.</code> and hit tab.  Try several of the methods that are listed there and see how they are built specifically for that type.</h4>

      <h3>More Pythonic Programming</h3>
      
      <p>
      There are several useful built in functions in python and other idioms that you end up using quite a bit.
      In this example, I use <code>join, reduce, lambda</code> and more list comprehensions.

      <div class="youtube">
	<iframe width="560" height="315" src="https://www.youtube.com/embed/9jaZhCz72Yk" frameborder="0" allowfullscreen></iframe>
	<b>Lambda, Reduce, Join</b>
      </div>

      <h4>Checkpoint: In this example, I could have used the <code>map</code> function to extract the first letter of each name.  Do this instead of the list comprehension, and combine them using join.  Try to make it so that these letters are separated by a ",".</h4>
      
      I keep saying the word iterable, but what is really going on with them.
      An iterable is an object that can be turned into an iterator object (not terribly informative).
      An iterator object is one in which the next method is well defined.
      For example, in your ipython instance, run the following lines:
<pre><code>l = range(10)
li = iter(l)
print type(li)
print li.next()
print li.next()
for i in li:
    print i</code></pre>
What should have happened is that your <code>li</code> object kept track of where you were in terms of iterating through the list <code>[1,2,...,10]</code>.
This is roughly how for loops, and list comprehensions, work in python, and in fact much of the logic of python is build around iterator objects.
We will run into iterator objects when we read files, in pandas, and in many other situations.
      </p>

      <h3>Data Structures and dictionaries</h3>
      
      <p>	
	Let's revisit dictionaries.  Why do we have a dictionary and a list in Python?  If you want to map an integer index to a list of values, then a list is great.
	With a list x, you can look up <code>x[i]</code>, and it is extremely fast.
	When the index (or key) is not a positive integer with consecutive entries then the list is not enough.
	For this we use a dictionary, where the key can be strings, integers, and floats.
	The following example shows the usefulness of dictionaries.
	If you want to see how long an expression takes to run you can use the ipython magic function <code>%time</code>.
      </p>

      <div class="youtube">
	<iframe width="560" height="315" src="https://www.youtube.com/embed/4zJJX5Tbwxo" frameborder="0" allowfullscreen></iframe>
	<b>Data Structures:</b> A little bit about data structures, correction: I said that list lookup takes linear time, when I meant to say constant time (which I haven't defined yet).
      </div>

      <div class="youtube">
	<iframe width="560" height="315" src="https://www.youtube.com/embed/QjD4ZDMGOuM" frameborder="0" allowfullscreen></iframe>
	<b>Testing these algorithms:</b> we compare list.index, dictionaries, and sorted lists <a href="code/datastruct.py">(code)</a>
      </div>


     <footer class="site-footer">
	Copyright James Sharpnack &copy; 2016
     </footer>

    </section>

  
  </body>
</html>
